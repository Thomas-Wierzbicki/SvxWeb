// server.js — SVXLink Web Backend (Node.js + Express, ES Modules)

import express from "express";
import cors from "cors";
import bodyParser from "body-parser";
import fs from "fs/promises";
import fss from "fs";
import https from "https";
import readline from "readline";
import os from "os";
import { spawn, exec as execCb } from "child_process";

const SVXWEB_VERSION = process.env.SVXWEB_VERSION || "0.6.9";

// ========== Helpers ==========
const exec = (cmd) =>
  new Promise((res, rej) =>
    execCb(cmd, (e, so, se) =>
      e ? rej(new Error((se || so || "").trim() || String(e))) : res({ stdout: so, stderr: se })
    )
  );

const USE_SUDO = process.env.SVX_USE_SUDO === "1";
const run = (cmd) => exec(USE_SUDO ? `sudo ${cmd}` : cmd);

// ========== Config ==========
const PORT = parseInt(process.env.PORT || "3030", 10);
const SERVICE = process.env.SVX_SERVICE_NAME || "svxlink";
const CONFIG_DIR = process.env.SVX_CONFIG_DIR || "/etc/svxlink";
const ALLOWED_FILES = (process.env.SVX_ALLOWED_FILES ||
  "svxlink.conf,remotetrx.conf,modules.d/ModuleEchoLink.conf,modules.d/ModuleDtmfRepeater.conf,logic.tcl")
  .split(",")
  .map((s) => s.trim())
  .filter(Boolean);
const DTMF_PTY = process.env.SVX_DTMF_PTY || "/dev/shm/dtmf_ctrl";
const API_KEY = process.env.SVX_API_KEY || "";
const FRONTEND_DIR = process.env.FRONTEND_DIR || "";
const LOG_FILE = process.env.SVX_LOG_FILE || "/var/log/svxlink";

// ========== Small parsers for status ==========
async function getSvxlinkVersion() {
  try {
    const { stdout } = await run("svxlink --version");
    const first = (stdout || "").split(/\r?\n/)[0] || "";
    return first.trim() || null;
  } catch {
    return null;
  }
}

async function getCallsign() {
  const candidates = [
    `${CONFIG_DIR}/modules.d/ModuleEchoLink.conf`,
    `${CONFIG_DIR}/svxlink.conf`,
  ];
  for (const p of candidates) {
    try {
      if (!fss.existsSync(p)) continue;
      const txt = await fs.readFile(p, "utf8");
      const m = txt.match(/^\s*CALLSIGN\s*=\s*([^\s#]+)/m);
      if (m && m[1]) return m[1].trim();
    } catch {}
  }
  return null;
}

async function getModulesList() {
  try {
    const p = `${CONFIG_DIR}/svxlink.conf`;
    if (!fss.existsSync(p)) return [];
    const txt = await fs.readFile(p, "utf8");
    const m = txt.match(/^\s*MODULES\s*=\s*([^\r\n#]+)/m);
    if (!m) return [];
    return m[1]
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean)
      .map((name) => ({ name }));
  } catch {
    return [];
  }
}

// ========== App ==========
const app = express();
app.use(cors());
app.use(bodyParser.json({ limit: "1mb" }));
if (FRONTEND_DIR && fss.existsSync(FRONTEND_DIR)) {
  app.use(express.static(FRONTEND_DIR));
}

// ========== Status ==========
app.get("/api/status", async (_req, res) => {
  try {
    const { stdout } = await run(`systemctl show ${SERVICE}.service --no-page`);
    const map = Object.fromEntries(
      stdout
        .split(/\r?\n/)
        .filter(Boolean)
        .map((l) => l.split("=", 2))
    );

    const [version, nodeCall, modules] = await Promise.all([
      getSvxlinkVersion(),
      getCallsign(),
      getModulesList(),
    ]);

    res.json({
      serviceState: map.ActiveState || "unknown",
      service: map.ActiveState || "unknown",
      uptime: map.ActiveEnterTimestamp || null,
      svxwebVersion: SVXWEB_VERSION,
      version,    // SVXLink Version
      nodeCall,   // Rufzeichen
      modules,    // Module-Liste
    });
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

// ========== Service-Steuerung ==========
app.post("/api/service/:cmd", async (req, res) => {
  const cmd = String(req.params.cmd || "");
  if (!/^(status|start|stop|restart|reload)$/.test(cmd)) {
    return res.status(400).send("invalid command");
  }
  try {
    await run(`systemctl ${cmd} ${SERVICE}.service`);
    res.json({ ok: true });
  } catch (e) {
    res.status(500).send(String(e.message || e));
  }
});

// ========== DTMF ==========
app.post("/api/dtmf", async (req, res) => {
  const digits = (req.body?.digits || "").trim();
  if (!digits) return res.status(400).json({ error: "missing digits" });
  try {
    await fs.writeFile(DTMF_PTY, digits + "\n");
    res.json({ ok: true });
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

// ========== EchoLink (Basics) ==========
app.get("/api/echolink/conferences", async (_req, res) => {
  res.json({ conferences: ["*ECHOTEST*", "*AMSAT*", "*DODROPIN*"] });
});
app.post("/api/echolink/connect", (req, res) => {
  res.json({ ok: true, target: req.body?.target || "" });
});
app.post("/api/echolink/disconnect", (_req, res) => {
  res.json({ ok: true });
});

// ========== Logs ==========
app.get("/api/logs/source", (_req, res) => {
  const fileExists = fss.existsSync(LOG_FILE);
  res.json({ journal: true, file: fileExists, logFile: LOG_FILE });
});

app.get("/api/logs/tail", async (req, res) => {
  const lines = Math.max(1, Math.min(2000, parseInt(String(req.query.lines || "200"), 10)));
  try {
    const { stdout } = await run(`journalctl -u ${SERVICE}.service -n ${lines} -o cat`);
    const arr = (stdout || "").trim() ? (stdout || "").trim().split(/\r?\n/) : [];
    res.json({ lines: arr });
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

app.get("/api/logs/filetail", async (req, res) => {
  const lines = Math.max(1, Math.min(2000, parseInt(String(req.query.lines || "200"), 10)));
  try {
    const { stdout } = await run(`tail -n ${lines} ${LOG_FILE}`);
    const arr = (stdout || "").trim() ? (stdout || "").trim().split(/\r?\n/) : [];
    res.json({ lines: arr, file: LOG_FILE });
  } catch (e) {
    res.status(500).json({ error: String(e.message || e), file: LOG_FILE });
  }
});

// Live-Streams per SSE
app.get("/api/logs/stream", async (req, res) => {
  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Cache-Control", "no-cache");
  res.setHeader("Connection", "keep-alive");
  res.flushHeaders?.();
  const child = spawn("journalctl", ["-u", `${SERVICE}.service`, "-f", "-o", "cat"], {
    stdio: ["ignore", "pipe", "pipe"],
  });
  const rl = readline.createInterface({ input: child.stdout });
  const send = (line) => res.write(`data: ${String(line).replace(/\n/g, " ")}\n\n`);
  rl.on("line", send);
  child.stderr?.on("data", (d) => send(String(d)));
  req.on("close", () => {
    try { rl.close(); } catch {}
    try { child.kill("SIGTERM"); } catch {}
  });
});

app.get("/api/logs/stream_file", async (req, res) => {
  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Cache-Control", "no-cache");
  res.setHeader("Connection", "keep-alive");
  res.flushHeaders?.();
  const child = spawn("tail", ["-n", "0", "-F", LOG_FILE], { stdio: ["ignore", "pipe", "pipe"] });
  const rl = readline.createInterface({ input: child.stdout });
  const send = (line) => res.write(`data: ${String(line).replace(/\n/g, " ")}\n\n`);
  rl.on("line", send);
  child.stderr?.on("data", (d) => send(String(d)));
  req.on("close", () => {
    try { rl.close(); } catch {}
    try { child.kill("SIGTERM"); } catch {}
  });
});

// ========== Netzwerk: IP-Adressen ==========
app.get("/api/network/addresses", (_req, res) => {
  try {
    const nets = os.networkInterfaces();
    const items = [];
    for (const [iface, addrs] of Object.entries(nets)) {
      for (const a of addrs || []) {
        items.push({
          iface,
          family: a.family,
          address: a.address,
          netmask: a.netmask,
          cidr: a.cidr || null,
          mac: a.mac || null,
          internal: !!a.internal,
          scopeid: a.scopeid ?? null,
        });
      }
    }
    res.json({ items });
  } catch (e) {
    res.status(500).json({ error: String(e.message || e) });
  }
});

// ========== EchoLink Logins ==========
function fetchHTML(url) {
  return new Promise((resolve, reject) => {
    https
      .get(url, (res) => {
        if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
          return fetchHTML(res.headers.location).then(resolve, reject);
        }
        let data = "";
        res.on("data", (c) => (data += c));
        res.on("end", () => resolve(data));
      })
      .on("error", reject);
  });
}
function stripTags(s) {
  return String(s || "")
    .replace(/<br\s*\/?>/gi, "\n")
    .replace(/<[^>]+>/g, " ")
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/\s+/g, " ")
    .trim();
}
app.get("/api/echolink/logins", async (req, res) => {
  const type = String(req.query.type || "conf");
  try {
    const html = await fetchHTML("https://www.echolink.org/logins.jsp");
    const headerTr = [...html.matchAll(/<tr[^>]*>([\s\S]*?)<\/tr>/gi)]
      .map((m) => m[1])
      .find((r) => /<th/i.test(r));
    const headers = headerTr
      ? [...headerTr.matchAll(/<th[^>]*>([\s\S]*?)<\/th>/gi)].map((m) => stripTags(m[1]))
      : [];
    const rowsHtml = [...html.matchAll(/<tr[^>]*>([\s\S]*?)<\/tr>/gi)]
      .map((m) => m[1])
      .filter((r) => /<td/i.test(r));
    let items = rowsHtml.map((r) => {
      const cols = [...r.matchAll(/<td[^>]*>([\s\S]*?)<\/td>/gi)].map((m) => stripTags(m[1]));
      return cols;
    });
    if (type === "conf") {
      items = items.filter((cols) => (cols[0] || "").includes("*"));
    }
    const hdr = headers.length ? headers : ["Callsign", "Beschreibung", "Location", "Status"];
    res.json({ headers: hdr, rows: items, type });
  } catch (e) {
    res.status(500).json({ error: String(e?.message || e) });
  }
});

// ========== Start ==========
app.listen(PORT, () => {
  console.log(`SVXWeb Backend v${SVXWEB_VERSION} läuft auf Port ${PORT}`);
});
